package ds

import "fmt"

// 10.4-1
// 18  12,10  7,4,2,21 ,,5,

// 10.4-2
// 中序遍历

// 10.4-3
// A. 把从根节点到最小节点路径上的所有节点都入栈
// B. 弹出栈顶元素，打印此数据
// C. 取当前打印节点的右节点
//     C1.  如果右节点为空， go B
//     C2. 如果右节点不为空，则把右节点及其相应的所有左子节点都入栈, go B
// D. 循环B直至栈变为空

// 10.4-4
// 需要中序遍历
// 递归方法
// A. 打印根节点
// B. 把左节点及其所有右兄弟节点当做n个独立的树，依次递归打印

func (this *RootTree) PrintTree(){
	fmt.Println(this.root.Value)
	left := this.root.left 
	for left != nil {
		right := left.rightSibling
		(&RootTree{left}).PrintTree()
		left = right
	}
}

func Test_PrintTree(){
	r := &RootTree{}
	r.Insert(1)
	r.Insert(2)
	r.Insert(2)
	r.Insert(26)
	r.Insert(2)
	r.PrintTree()
}

// 迭代算法
// 使用辅助性栈
// A. 打印根节点
// B. 取根节点的左节点
//   C1. 如果左节点为空，则完成
//   C2. 如果左节点不能空，打印左节点，并把左节点入栈
//     


// 10.4-5
// 使用父指针来回溯
// A. 从根节点一直遍历到最左节点，打印这个节点，这个节点可定没有右兄弟节点
// B. 从父指针回溯到上一个节点，然后打印打印当前节点
//  C1. 如果此节点是root节点，则结束
//  C2. 取次节点的右兄弟的第一个节点，然后go A 循环

// 10.4-6
// 使用2个指针left, right, 父节点的左指针指向最左边的子节点
// 右指针指向最右边的节点，最左边的节点的右指针指向下一个
// 子节点，最右边节点的boolea为真，其右指针指向父节点，因为这个节点的
// 右指针是没有用途的
// 查找所有子节点
// 从左孩子开始遍历，取下一个节点的右节点，直到父节点，所遍历的所有节点就是子节点
// 查找父节点
// 从这个节点开始取所有右节点，当遇到boolean值为true的节点的下一个节点就是父节点